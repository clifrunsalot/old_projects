import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.event.*;
import java.awt.Font;
import java.awt.Insets;

import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;

import java.lang.Math;
import java.lang.Long;
import java.lang.Double;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.Vector;

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.JFormattedTextField.*;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableColumn;
import javax.swing.SwingConstants;

class RangeVerifier extends InputVerifier 
{
	public RangeVerifier(Double s, Double e)
	{
		dStart = s;
		dEnd   = e;
		type = "double";
	}

	public RangeVerifier(Integer s, Integer e)
	{
		iStart = s;
		iEnd   = e;
		type = "integer";
	}

	public RangeVerifier(Long s, Long e)
	{
		lStart = s;
		lEnd   = e;
		type = "long";
	}
	
	public boolean verify(JComponent input) 
	{
		if (input instanceof JFormattedTextField) 
		{
			GenericTextField gtf = (GenericTextField)input;
			String text = gtf.getText();
			
			try
			{
				NumberFormat nf = NumberFormat.getNumberInstance();
				nf.setParseIntegerOnly(false);

				Number value = nf.parse(text);

				if (type.equals("double"))
				{
					if ((value.doubleValue() > (dStart.doubleValue() - 0.01)) 
							&& (value.doubleValue() <= dEnd.doubleValue()))
					{
						return true;
					}
					else
					{
						return false;
					}
				}
				else if(type.equals("integer"))
				{
					if ((value.intValue() > iStart.intValue()) 
							&& (value.intValue() <= iEnd.intValue()))
					{
						return true;
					}
					else
					{
						return false;
					}
				}
				else if(type.equals("long"))
				{
					if ((value.longValue() > lStart.longValue()) 
							&& (value.longValue() <= lEnd.longValue()))
					{
						return true;
					}
					else
					{
						return false;
					}
				}
			}
			catch (ParseException pe)
			{
				return false;
			}
		}
		return false; 
	}

	public boolean shouldYieldFocus(JComponent input)
	{
		return verify(input);
	}

	private String type;
	private Double dStart;
	private Double dEnd;
	private Integer iStart;
	private Integer iEnd;
	private Long lStart;
	private Long lEnd;
}

class GenericTextField extends JFormattedTextField
{
		public GenericTextField(NumberFormat format,
										int width,
										Double start, 
										Double end)
		{
			super(format);
			setHorizontalAlignment(JTextField.RIGHT);
			setColumns(width);
			setInputVerifier(new RangeVerifier(start,end));
		}

		public GenericTextField(NumberFormat format, 
										int width,
										Integer start, 
										Integer end)
		{
			super(format);
			setHorizontalAlignment(JTextField.RIGHT);
			setColumns(width);
			setInputVerifier(new RangeVerifier(start,end));
		}

		public GenericTextField(NumberFormat format,
										int width,
										Long start,
										Long end)
		{
			super(format);
			setHorizontalAlignment(JTextField.RIGHT);
			setColumns(width);
			setInputVerifier(new RangeVerifier(start,end));
		}

		public GenericTextField(NumberFormat format,
										int width)
		{
			super(format);
			setHorizontalAlignment(JTextField.RIGHT);
			setColumns(width);
			setEditable(false);
		}
}

strictfp class Point
{
	public Point(double lt, double lg, double dist)
	{
		latitude   = lt;
		longitude  = lg;
		distance   = dist;
	}

	public Point(double lt, double lg, double dist, long tm)
	{
		latitude   = lt;
		longitude  = lg;
		distance   = dist;
		timeOffset = tm;
	}

	public double getLongDeg()
	{
		return ((longitude * 180)/Math.PI);
	}

	public double getLatDeg()
	{
		return ((latitude * 180)/Math.PI);
	}
	public double getDistanceKm()
	{
		double radiusEarthKms = 6366.71;
		return ((Math.toDegrees(distance)/180) * Math.PI * radiusEarthKms);
	}

	public long getTimeOffset()
	{
		return timeOffset;
	}

	private double longitude;
	private double latitude;
	private double distance;
	private long timeOffset;
}

class DoubleRenderer extends DefaultTableCellRenderer
{
    public DoubleRenderer()
	{
		super(); 
		setHorizontalAlignment(SwingConstants.RIGHT);
		format = NumberFormat.getNumberInstance();
		format.setMinimumFractionDigits(4);
		format.setMaximumFractionDigits(4);
	}

    public void setValue(Object value)
	{
       	setText(format.format(value));
    }

    private NumberFormat format;
}

class DistanceRenderer extends DefaultTableCellRenderer
{
    public DistanceRenderer()
	{
		super(); 
		setHorizontalAlignment(SwingConstants.RIGHT);
		format = NumberFormat.getNumberInstance();
		format.setMinimumFractionDigits(2);
		format.setMaximumFractionDigits(2);
	}

    public void setValue(Object value)
	{
       	setText(format.format(value));
    }

    private NumberFormat format;
}

class Distance extends Number
{
	public Distance(double d)
	{
		value = new Double(d);
	}

	public double doubleValue()
	{
		return value.doubleValue();
	}

	public float floatValue()
	{
		return (float)value.doubleValue();
	}

	public int intValue()
	{
		return (int)value.doubleValue();
	}

	public long longValue()
	{
		return (long)value.doubleValue();
	}

	private Double value;
}


class TableModel extends DefaultTableModel
{
	public TableModel(Vector p)
	{
		path = p;
		cols = 4;
		rows = p.size();
	}

	public int getRowCount()
	{
		return rows;
	}

	public int getColumnCount()
	{
		return cols;
	}

    public Class getColumnClass(int c) {
        return getValueAt(0, c).getClass();
    }

	public Object getValueAt(int r, int c)
	{
		Point p = (Point)path.elementAt(r);
		Object item = "";
		if (c == 0)
		{
			item = new Integer(r);
		}
		else if (c == 1)
		{
			item = new Double(p.getLatDeg());
		}
		else if (c == 2)
		{
			item = new Double(p.getLongDeg());
		}
		else if (c == 3)
		{
			item = new Distance(p.getDistanceKm());
		}
		return item;
	}

	public String getColumnName(int c)
	{
		String item = "";
		if (c == 0)
		{
			item = new String("Index");
		}
		else if (c == 1)
		{
			item = new String("Latitude");
		}
		else if (c == 2)
		{
			item = new String("Longitude");
		}
		else if (c == 3)
		{
			item = new String("Distance");
		}
		return item;
	}

	private int rows;
	private int cols;
	private Vector path;
}

	
strictfp class FlightPath
{
	public FlightPath(){}

	public FlightPath(double oLat, 
						double oLong,
						double dLat,
						double dLong,
						double alt,
						double spd,
						double incr,
						long time)
	{
		incrementPath = new Vector();
		offsetPath    = new Vector();

		origLat       = toRadians(oLat);
		origLong      = toRadians(oLong);
		destLat       = toRadians(dLat);
		destLong      = toRadians(dLong);
		altitude      = alt;
		speed         = spd;
		increment     = incr;
		timeInterval  = time;

		totalDistance = getDistance(origLat, origLong, destLat, destLong);
		totalTimeMS   = getTimeMilliSecondsBasedOnKm(totalDistance,speed);

		createPathBasedOnIncrements();
		createPathBasedOnTimeInterval();
	}

	double getCourse(double oLat, double oLong, double dLat, double dLong, double dist)
	{
		double course = 0;

		if (Math.sin(dLong - oLong) < 0)
		{

			course = Math.acos((Math.sin(dLat) - Math.sin(oLat) * Math.cos(dist)) /
					(Math.sin(dist) * Math.cos(oLat)));
		}
		else
		{
			course = 2 * Math.PI - Math.acos((Math.sin(dLat) - Math.sin(oLat) * Math.cos(dist)) /
					(Math.sin(dist) * Math.cos(oLat)));
		}


//		double a = (Math.sin(oLong - dLong) * Math.cos(dLat));
//		double b = (Math.cos(oLat) * Math.sin(dLat) - Math.sin(oLat) * Math.cos(dLat) * Math.cos(oLong - dLong));
//		double c = Math.IEEEremainder(Math.atan(a/b), 2 * Math.PI);
//
//		if (c < 0)
//		{
//			course = -c;
//		}
//		else
//		{
//			course = c;
//		}

//		System.out.println("sin(dLong - oLong) = " + Math.sin(dLong - oLong));
//		System.out.println("oLat =               " + oLat);
//		System.out.println("oLong =              " + oLong);
//		System.out.println("dLat =               " + dLat);
//		System.out.println("dLong =              " + dLong);
//		System.out.println("dist =               " + dist);
		System.out.println("course =             " + course); 


		return course;
	}

	double getDestLat(double oLat, double course, double dist)
	{
		return (Math.asin(Math.sin(oLat) * Math.cos(dist) + Math.cos(oLat) * Math.sin(dist) * Math.cos(course)));
	}

	double getDestLong(double oLong, double oLat, double dLat, double course, double dist)
	{
		double dLong = 0;

		if(Math.cos(dLat) == 0)
		{
			dLong = oLong;
		}
		else
		{
			//
			// For distances < pi/2
			// 
//			double a = Math.atan((Math.sin(course) * Math.sin(dist) * Math.cos(oLat)) / 
//							(Math.cos(dist) - Math.sin(oLat) * Math.sin(dLat)));
//			double b = Math.IEEEremainder(oLong - a + Math.PI, 2 * Math.PI);
//
//			if (b < 0)
//			{
//				dLong = -(b) - Math.PI;
//			}
//			else
//			{
//				dLong = b - Math.PI;
//			}
//
			// For all distances
			double a = Math.sin(course) * Math.sin(dist) * Math.cos(oLat);
			double b = Math.cos(dist) - Math.sin(oLat) * Math.sin(dLat);
			double c = Math.atan(a/b);
			double d = Math.IEEEremainder(oLong - c + Math.PI, 2 * Math.PI);

			if (d < 0)
			{
				dLong = -d - Math.PI;
			}
			else
			{
				dLong = d - Math.PI;
			}
		}

		return dLong;
	}

	long getReasonableMaxOffset(long tmInterval)
	{
		return (totalTimeMS/tmInterval) <= 1000 ? (long)totalTimeMS : 1000 * tmInterval;
	}

	void createPathBasedOnTimeInterval()
	{
		long start       = timeInterval;
		double iDistance = 0;
		double iLat      = 0;
		double iLong     = 0;
		long offset      = 0;
		long lastOffset  = 0;
		Point p;

		// Get initial course based on orig/dest coordinates and total distance
		// 
		double course = getCourse(origLat, origLong, destLat, destLong, totalDistance);

		long maxOffset = getReasonableMaxOffset(timeInterval);

		for(offset=0; offset<totalTimeMS; offset += timeInterval)
		{
			iDistance = getDistance(offset, speed);
			iLat      = getDestLat(origLat, course, iDistance);
			iLong     = getDestLong(origLong, origLat, iLat, course, iDistance);
			p         = new Point(iLat, iLong, iDistance, offset);
			offsetPath.addElement(p);
			lastOffset = offset;
		}

		if(lastOffset < totalTimeMS)
		{
			long diff = (long)totalTimeMS - lastOffset;
			iDistance = iDistance + getDistance(diff, speed);
			iLat      = getDestLat(origLat, course, iDistance);
			iLong     = getDestLong(origLong, origLat, iLat, course, iDistance);
			p         = new Point(iLat, iLong, iDistance, lastOffset + diff);
			offsetPath.addElement(p);
		}

	}

	void createPathBasedOnIncrements()
	{
		Point p;
		double A     = 0;
		double B     = 0;
		double x     = 0;
		double y     = 0;
		double z     = 0;
		double iLat  = 0;
		double iLong = 0;
		double iAlt  = 0;
		double iDist = 0;

		for(int i=0; i<=increment; i++)
		{
				A     = Math.sin((1 - (i/increment)) * totalDistance) / Math.sin(totalDistance);
				B     = Math.sin((i/increment) * totalDistance) / Math.sin(totalDistance);
				x     = A * Math.cos(origLat) * Math.cos(origLong) + B * Math.cos(destLat) * Math.cos(destLong);
				y     = A * Math.cos(origLat) * Math.sin(origLong) + B * Math.cos(destLat) * Math.sin(destLong);
				z     = A * Math.sin(origLat)                      + B * Math.sin(destLat);
				iLat  = Math.atan2(z, Math.sqrt(Math.pow(x,2) + Math.pow(y,2)));
				iLong = Math.atan2(y, x);
				iAlt  = 0;
				iDist = getDistance(origLat,origLong,iLat,iLong);
				p = new Point(iLat, iLong, iDist);
				incrementPath.addElement(p);
		}
	}

	public double getDistance(double timeMS, double spdKPH)
	{
		double radiusEarthKms = 6366.71;
		return (timeMS * spdKPH) / (1000 * 60 * 60 * radiusEarthKms);
	}

	public double getDistance(double oLat, double oLong, double dLat, double dLong)
	{
		return Math.acos(Math.sin(oLat) 
									* Math.sin(dLat) 
									+ Math.cos(oLat) 
									* Math.cos(dLat)
									* Math.cos(oLong - dLong));
	}

	public double getTimeMilliSecondsBasedOnKm(double dist, double spd)
	{
		double radiusEarthKms = 6366.71;
		return dist * radiusEarthKms * 1000 * 60 * 60 / spd;
	}

	public Vector getIncrementPath()
	{
		return incrementPath;
	}

	public Vector getTimeIntervalPath()
	{
		return offsetPath;
	}

	public double getTimeMS()
	{
		return totalTimeMS;
	}

	public double getTimeSec()
	{
		return (totalTimeMS / 1000);
	}

	public double getTimeMin()
	{
		return (totalTimeMS / (1000 * 60));
	}

	public double getTimeHr()
	{
		return (totalTimeMS / (1000 * 60 * 60));
	}

	public double getDistanceRadians()
	{
		return totalDistance;
	}

	public double getDistanceKm()
	{
		double radiusEarthKms = 6366.71;
		return ((Math.toDegrees(totalDistance)/180) * Math.PI * radiusEarthKms);
	}

	public double getDistanceMiles()
	{
		double radiusEarthMiles = 3956.09;
		return ((Math.toDegrees(totalDistance)/180) * Math.PI * radiusEarthMiles);
	}

	public double getDistanceNms()
	{
		double radiusEarthNms = 3435.43;
		return ((Math.toDegrees(totalDistance)/180) * Math.PI * radiusEarthNms);
	}

	public double toRadians(double degree)
	{
		return degree * Math.PI / 180;
	}

	public void printTimeIntervalPath()
	{
		NumberFormat timeFormat = NumberFormat.getNumberInstance();
		timeFormat.setMaximumFractionDigits(2);

		NumberFormat degFormat = NumberFormat.getNumberInstance();
		degFormat.setMaximumFractionDigits(4);
		
		NumberFormat distFormat = NumberFormat.getNumberInstance();
		distFormat.setMaximumFractionDigits(4);
		
		for(int i=0; i<offsetPath.size(); i++)
		{
			Point p = (Point)offsetPath.elementAt(i);
			System.out.println("" + i + ":\t" 
							+ timeFormat.format(p.getTimeOffset()) + "\t"
							+ degFormat.format(p.getLatDeg()) + "\t"
							+ degFormat.format(p.getLongDeg()) + "\t"
							+ distFormat.format(p.getDistanceKm()));
		}
	}

	public void printIncrementPath()
	{
		NumberFormat degFormat = NumberFormat.getNumberInstance();
		degFormat.setMinimumFractionDigits(4);
		degFormat.setMaximumFractionDigits(4);
		
		for(int i=0; i<incrementPath.size(); i++)
		{
			Point p = (Point)incrementPath.elementAt(i);
			System.out.println("" + i + ":\t" 
							+ degFormat.format(p.getLatDeg()) + "\t"
							+ degFormat.format(p.getLongDeg()) + "\t"
							+ degFormat.format(p.getDistanceKm()));
		}
	}
	
	private double origLong,
						origLat,
						destLong,
						destLat,
						altitude,
						speed,
						totalDistance,
						increment,
						totalTimeMS;
	private long timeInterval;
	private Point point;
	private Vector incrementPath,
					offsetPath;
}


class FlightPathGui extends JFrame
{
	public FlightPathGui()
	{
		setTitle("Flight Path Generator");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		panel = new JPanel();
		panel.setLayout(new GridBagLayout());
		Border border = BorderFactory.createEtchedBorder(EtchedBorder.LOWERED);

		add(panel,new JLabel("Latitude"),2,1,1,1,"C");
		add(panel,new JLabel("Longitude"),4,1,1,1,"C");

		NumberFormat degFormat = NumberFormat.getNumberInstance();
		degFormat.setMaximumIntegerDigits(3);
		degFormat.setMinimumFractionDigits(4);
		degFormat.setMaximumFractionDigits(4);
		
		origLatTF  = new GenericTextField(degFormat,6,new Double(-179.9999),new Double(180.0000));
		origLongTF = new GenericTextField(degFormat,6,new Double(-179.9999),new Double(180.0000));
		destLatTF  = new GenericTextField(degFormat,6,new Double(-179.9999),new Double(180.0000));
		destLongTF = new GenericTextField(degFormat,6,new Double(-179.9999),new Double(180.0000));

		origLatTF.setValue(new Double(0.0000));
		origLongTF.setValue(new Double(0.0000));
		destLatTF.setValue(new Double(0.0000));
		destLongTF.setValue(new Double(0.0000));

		add(panel,new JLabel("Origin"),1,2,1,1,"E");
		add(panel,origLatTF,2,2,1,1,"E");
		add(panel,Box.createRigidArea(new Dimension(20,20)),3,2,1,1,"E");
		add(panel,origLongTF,4,2,1,1,"E");
	
		add(panel,new JLabel("Destination"),1,3,1,1,"E");
		add(panel,destLatTF,2,3,1,1,"E");
		add(panel,Box.createRigidArea(new Dimension(20,20)),3,3,1,1,"C");
		add(panel,destLongTF,4,3,1,1,"E");

		JLabel warning = new JLabel("Prefix East Latitude and South Longitude with a '-'");
		warning.setFont(new Font("Courier", Font.PLAIN, 12));
		warning.setForeground(new Color(0xff0000));
		warningPanel = new JPanel();
		warningPanel.add(warning);

		topPanel = new JPanel();
		topPanel.setLayout(new BoxLayout(topPanel,BoxLayout.Y_AXIS));
		topPanel.setBorder(border);
		topPanel.add(panel);
		topPanel.add(warningPanel);

		NumberFormat intFormat = NumberFormat.getNumberInstance();
		intFormat.setMaximumIntegerDigits(10);
		intFormat.setMinimumFractionDigits(0);
		intFormat.setMaximumFractionDigits(0);

		middlePanel = new JPanel(new GridBagLayout());
		middlePanel.setBorder(border);

		altitudeTF = new GenericTextField(intFormat,6,new Integer(-1),new Integer(99999));
		altitudeTF.setValue(new Integer(0));
		add(middlePanel,new JLabel("Altitude (m)"),1,1,1,1,"E");
		add(middlePanel,altitudeTF,2,1,1,1,"E");
		
		add(middlePanel,Box.createRigidArea(new Dimension(20,20)),3,1,1,1,"C");
		
		speedTF = new GenericTextField(intFormat,6,new Integer(-1),new Integer(99999));
		speedTF.setValue(new Integer(0));
		add(middlePanel,new JLabel("Speed (kph)"),4,1,1,1,"E");
		add(middlePanel,speedTF,5,1,1,1,"E");

		intermediatePtTF = new GenericTextField(intFormat,6,new Integer(-1), new Integer(100000));
		intermediatePtTF.setValue(new Integer(0));
		add(middlePanel,new JLabel("Intermediate Points"),1,2,1,1,"E");
		add(middlePanel,intermediatePtTF,2,2,1,1,"E");

		add(middlePanel,Box.createRigidArea(new Dimension(20,20)),3,2,1,1,"C");
		
		timeIntervalTF = new GenericTextField(intFormat,10,new Integer(-1), new Integer(1000000000));
		timeIntervalTF.setValue(new Integer(0));
		add(middlePanel,new JLabel("Time Interval (ms)"),4,2,1,1,"E");
		add(middlePanel,timeIntervalTF,5,2,1,1,"E");

		NumberFormat radiansFormat = NumberFormat.getNumberInstance();
		radiansFormat.setMaximumFractionDigits(6);
		
		NumberFormat distanceTimeFormat = NumberFormat.getNumberInstance();
		distanceTimeFormat.setMaximumFractionDigits(2);

		radiansTF       = new GenericTextField(radiansFormat,10);
		kilometersTF    = new GenericTextField(distanceTimeFormat,10);
		milesTF         = new GenericTextField(distanceTimeFormat,10);
		nauticalMilesTF = new GenericTextField(distanceTimeFormat,10);

		millisecondsTF  = new GenericTextField(distanceTimeFormat,10);
		secondsTF       = new GenericTextField(distanceTimeFormat,10);
		minutesTF       = new GenericTextField(distanceTimeFormat,10);
		hoursTF         = new GenericTextField(distanceTimeFormat,10);
		
		distanceTimePanel = new JPanel(new GridBagLayout());
		distanceTimePanel.setBorder(border);

		add(distanceTimePanel,new JLabel("Distance"),2,1,1,1,"C");

		add(distanceTimePanel,new JLabel("Radians"),1,2,1,1,"E");
		add(distanceTimePanel,radiansTF,2,2,1,1,"E");

		add(distanceTimePanel,new JLabel("Kilometers"),1,3,1,1,"E");
		add(distanceTimePanel,kilometersTF,2,3,1,1,"E");

		add(distanceTimePanel,new JLabel("Miles"),1,4,1,1,"E");
		add(distanceTimePanel,milesTF,2,4,1,1,"E");

		add(distanceTimePanel,new JLabel("Nautical Miles"),1,5,1,1,"E");
		add(distanceTimePanel,nauticalMilesTF,2,5,1,1,"E");

		add(distanceTimePanel,new JLabel("Travel Time"),4,1,2,1,"C");
		
		add(distanceTimePanel,new JLabel("Milliseconds"),3,2,1,1,"E");
		add(distanceTimePanel,millisecondsTF,4,2,1,1,"E");

		add(distanceTimePanel,new JLabel("Seconds"),3,3,1,1,"E");
		add(distanceTimePanel,secondsTF,4,3,1,1,"E");

		add(distanceTimePanel,new JLabel("Minutes"),3,4,1,1,"E");
		add(distanceTimePanel,minutesTF,4,4,1,1,"E");

		add(distanceTimePanel,new JLabel("Hours"),3,5,1,1,"E");
		add(distanceTimePanel,hoursTF,4,5,1,1,"E");

		calculateBtn = new JButton("Calculate");
		exitBtn = new JButton("Exit");
		bottomPanel = new JPanel();
		bottomPanel.setBorder(border);
		bottomPanel.add(calculateBtn);
		bottomPanel.add(exitBtn);

		table = new JTable();
		table.setColumnSelectionAllowed(true);
		table.setCellSelectionEnabled(true);
		JScrollPane scrollPane = new JScrollPane(table,
									JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
									JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		table.setPreferredScrollableViewportSize(new Dimension(300,300));
		table.setDefaultRenderer(Double.class,new DoubleRenderer());
		table.setDefaultRenderer(Distance.class,new DistanceRenderer());

		mainPanel = new JPanel();
		mainPanel.setLayout(new BoxLayout(mainPanel,BoxLayout.Y_AXIS));
		mainPanel.add(topPanel);
		mainPanel.add(middlePanel);
		mainPanel.add(distanceTimePanel);
		mainPanel.add(scrollPane);
		mainPanel.add(bottomPanel);

		getContentPane().add(mainPanel);
		pack();

		calculateBtn.addActionListener
		(
			new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("oLat =      " + origLatTF.getValue());
					System.out.println("oLong =     " + origLongTF.getValue());
					System.out.println("dLat =      " + destLatTF.getValue());
					System.out.println("dLong =     " + destLongTF.getValue());
					
					Double olat  = new Double(origLatTF.getValue().toString());
					Double olong = new Double(origLongTF.getValue().toString());
					Double dlat  = new Double(destLatTF.getValue().toString());
					Double dlong = new Double(destLongTF.getValue().toString());
			  		Double alt   = new Double(altitudeTF.getValue().toString());
			  		Double spd   = new Double(speedTF.getValue().toString());
					Double incre = new Double(intermediatePtTF.getValue().toString());
					Double time  = new Double(timeIntervalTF.getValue().toString());

					FlightPath p = new FlightPath(olat.doubleValue(), 
													olong.doubleValue(), 
													dlat.doubleValue(), 
													dlong.doubleValue(), 
													alt.doubleValue(), 
													spd.doubleValue(),
													incre.doubleValue(),
													time.longValue());

					radiansTF.setValue(new Double(p.getDistanceRadians()));
					kilometersTF.setValue(new Double(p.getDistanceKm()));
					milesTF.setValue(new Double(p.getDistanceMiles()));
					nauticalMilesTF.setValue(new Double(p.getDistanceNms()));
					millisecondsTF.setValue(new Double(p.getTimeMS()));
					secondsTF.setValue(new Double(p.getTimeSec()));
					minutesTF.setValue(new Double(p.getTimeMin()));
					hoursTF.setValue(new Double(p.getTimeHr()));

					TableModel model = new TableModel(p.getIncrementPath());
					table.setVisible(false);
					table.setModel(model);
					table.setVisible(true);

//					p.printIncrementPath();
					p.printTimeIntervalPath();
				}
			}
		);

		exitBtn.addActionListener
		(
		 	new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					System.exit(0);
				}
			}
		);
	}

	void add(Container c, Component comp, int x, int y, int w, int h, String anchor)
	{
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridx              = x;
		gbc.gridy              = y;
		gbc.gridwidth          = w;
		gbc.gridheight         = h;
		gbc.insets             = new Insets(3,3,3,3);

		if      (anchor.equals("C")){gbc.anchor = GridBagConstraints.CENTER;}
		else if (anchor.equals("E")){gbc.anchor = GridBagConstraints.EAST;}
		else if (anchor.equals("W")){gbc.anchor = GridBagConstraints.WEST;}

		c.add(comp,gbc);
	}		

	private JPanel mainPanel,
					panel,
					warningPanel,
					topPanel,
					middlePanel,
					distanceTimePanel,
					bottomPanel;

	private JButton calculateBtn,
	                exitBtn;

	private GenericTextField origLongTF,
							origLatTF,
							destLongTF,
							destLatTF,
							altitudeTF,
							speedTF,
							intermediatePtTF,
							timeIntervalTF,
							radiansTF,
							kilometersTF,
							milesTF,
							nauticalMilesTF,
							millisecondsTF,
							secondsTF,
							minutesTF,
							hoursTF;

	private JTable table;

}
		


public class createFlightPath
{
	public static void main(String [] args)
	{
		FlightPathGui path = new FlightPathGui();
		path.setVisible(true);
	}
}
